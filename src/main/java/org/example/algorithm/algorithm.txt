시간 복잡도
- 시간 복잡도(Time Complexity)는 문제를 해결 하는데 걸리는 시간과 입력의 함수 관계를 가리킴

여러가지 시간 복잡도 표기 방법
- Big-O(빅-오) -> 상한 점근(최악의 경우)
- 최악의 경우 : 알고리즘의 실행 시간이 입력에 대해 가장 오래 걸리는 경우
- Big-옴(빅-오메가) -> 하한 점근(최선의 경우)
- 최선의 경우 : 알고리즘의 실행 시간이 입력에 대해 가장 짧게 걸리는 경우
- Big-세타(빅-세타) -> 위 둘의 평균

대표적인 Big-O 표기법의 종류
        O(1)      0(log N)      O(N)      O(N log N)      O(N2)        O(2N)        O(N!)
N = 1     1           1          1            1             1            1            1
N = 4     1           2          4            8             16           16           24
N = 8     1           3          8            24            64           256         40320
명칭    상수 시간    로그 시간    선형 시간    로그 선형 시간     이차 시간      지수 시간     팩토리얼 시간
예시    인덱스에     이진 탐색    for 반복문     퀵 정렬의      2중 for 문    피보나치 수열     순열
       해당하는     (이분 탐색)              평균 시간 복잡도
        배열의
       요소 추출

0(1)
- 일정한 복잡도 (constant complexity)
- 입력값이 증가하더라도 실행 시간이 늘어나지 않는다.
  입력값의 크기와 관계없이, 즉시 출려값을 얻어낼 수 있음
- 예: 어떠한 배열의 특정 인덱스 위치의 요소 출력

0(log N)
- 로그 복잡도(logarithmic complexity)
- 시간 복잡도는 0(1) < 0(log N) < 0(N) 순으로 큼
  N이 커질수록 0(N)보다 0(1)에 더 가까워짐
- 매번 탐색 범위의 중간값을 제시할 때마다 경우의 수가 절반씩 줄어듦
- 특정 숫자를 맞추는 Up & Down 게임

0(N)
- 선형 복잡도(linear complexity)
- 입력값이 증가함에 따라 실행 시간 또한 같은 비율로 증가
- 계수는 생략
  입력값(N)이 커짐에 따라 계수의 의미가 퇴색되기 때문에
  아래 두 함수는 for 문의 반복 횟수가 다르지만, 모두 0(N)으로 표기(0(2N) -> 0(N))

0(N2)
- 2차 복잡도(quadratic complexity)
- 입력값이 증가함에 따라 실행 시간이 N의 제곱수의 비율로 증가
- 2중 for 문법에서 보이는 시간 복잡도 -> 0(N2)

0(2N)
- 지수 복잡도 or 기하급수적 복잡도(exponential complexity)
- 구현한 알고리즘의 시간 복잡도가 0(2N) 라면,
  보통 다른 접근 방식을 고민해 보는 것이 좋음

0(N!)
- 팩토리얼 시간 복잡도 (factorial complexity)
- 시간 복잡도가 가장 큼
- 3개의 서로 다른 공에 대한 총 6(3!) 가지의 순열(permutation)

예제 문제
- 크기가 N인 배열이 있고, 배열 안의 요소들은 모두 양의 정수이며, 오름차순으로 정렬되어 있다.
  이때, 배열 안에서 중복되지 않게 두 개를 골라 곱하였을 때의 최댓값을 구하여라.

- 두 수를 선택하는 경우의 수는
  시간 복잡도: 0(N2)
  N의 값이 백만, 천만 이상의 값이 되어버리면?

- 배열의 가장 뒤에 있는 요소와 2번째로 뒤에 있는 요소를 곱함
  시간 복잡도: 0(1)
  N의 값이 커지더라도, 보다 빠른 시간 안에 연산 가능

대략적인 시간 계산법
- Cpp 가 Python 과 Java 보다 빠르다.
- 보통 언어별로 시간 보정이 존재하므로, 평균하여 대략적으로 1초에 1억 번 연산

실제 문항에 적용한다면?
- N의 범위를 확인하고, 완전 탐색으로 해결 가능한 지 확인
- 떠오른 풀이법의 시간 복잡도로, 제한 시간 안에 만족할 수 있는지 확인
- 완전 탐색으로 제한 시간 내에 해결할 수 없을 것 같다면, 시간 복잡도가 작은 다른 알고리즘을 고민할 수 있음
- 시간 복잡도를 고민하지 않고, 무작정 구현부터 한다면 처음부터 다시 코드를 작성해야 하는 불상사가 생길 수 있음!
- 실제 코딩 테스트 응시 시간 내에 좀 더 많은 문항을 풀기 위해서는 이러한 연습을 많이 하는 것이 중요
- 시간 제한 : 1초
  N이 100000까지 입력되므로 0(N2)은 불가능
  0(N log N)의 시간 복잡도까지는 가능
  이러한 방식으로, N의 입력 범위를 통해 출제자가 의도한 풀이의 시간 복잡도를 추측할 수 있음

약수(Divisor)
- 어떠한 수를 나누어떨어지게 하는 수
- 나누어 떨어진다 -> 나머지가 0
- N의 약수의 개수를 구하는 방법
- 1부터 N이하의 정수로 N을 나누어서, 나머지가 0이 되는 수의 개수를 찾음
  시간 복잡도 : 0(N)
- 1부터 루트N이하의 정수로 N을 나누어서, 나머지가 0이 되는 수의 개수를 찾고, 그 개수에 2를 곱함 N이 제곱수면, 그 수에 1을 뺌
- 시간 복잡도 : 0(루트N)
- 제곱수 : 어떠한 정수의 제곱이 되는 정수

유클리드 호제법(Euclidean Algorithm)
- 호제법이란 말은 두 수가 서로 상대방 수를 나누어 원하는 수를 구하는 것을 의미
- 두 자연수 a, b와 b의 최대공약수는 b와 r의 최대공약수와 동일
- 이 성질에 따라 b를 r로 나눈 나머지 r1을 구하고, 다시 r을 r1로 나눈 나머지를 구하는 과정을 반복하여, 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수
- 예시 : 1071과 1029의 최대공약수를 구해보자.
  1071은 1029로 나누어 떨어지지 않기 때문에, 1071을 1029로 나눈 나머지를 계산 -> 42
  1029는 42로 나누어 떨어지지 않기 때문에, 1029를 42로 나눈 나머지를 계산 -> 21
  42는 21로 나누어 떨어지므로, 1071과 1029의 최대공약수는 21

GCD와 LCM
- GCD(Greatest Common Divisor = 최대공약수)
- LCM(Least Common Multiple = 최소공배수)
- LCM(a, b) = a * b / GCD(a,b)
- 어떠한 두 수의 곱은, 그 두 수의 최대공약수와 최소공배수의 곱과 같다.

표준 라이브러리 사용
- C++의 gcd, lcm 함수는 C++ 17 버전부터 지원 -> numeric 모듈
- Python에서는 math 모듈의 gcd와 lcm 함수 사용 -> gcd는 python 3.5, lcm 은 python 3.9이상 지원
- Java는 지원하지 않아서 직접 구현해야 함
- 코딩 테스트 사이트에서 제공하는 언어의 버전에 대해 사전 체크 필요

소수란?
- 소수(Prime Number)란 1과 자기 자신으로만 나누어지는 수를 의미 -> 약수가 2개
- 함성수(Composite Number)란 약수의 개수가 3개 이상인 수
- 단, 1은 소수도 아니고 합성수도 아님

소수 판별법(Primality Test)
- N의 약수의 개수를 세는 방법에는 크게 두 가지
- 1부터 N까지의 수로 N을 나눔
- 0(N)의 시간 복잡도
- 1부터 루트N까지의 수로 N을 나눔
- 0(루트N)의 시간 복잡도
- 두 방법은 단 하나의 수에 대해서만 소수를 판별
- 만약 1부터 N까지의 수들 중 소수를 판별하게 된다면, 기존의 시간 복잡도에 * N -> 더 좋은 방법은 없을까?

에라토스테네스의 체
- 에레토스테네스의 체는 이름 그대로 체로 걸러낸다고 생각하면 된다.
- 에라토스테네스의 체로 소수가 아닌 수들을 걸러내보자.
- 동작 순서
  1. 2부터 N까지 모든 정수를 적는다.
  2. 아직 지우지 않은 소수 중 가장 작은 소수를 찾는다. 이 수를 P라고 한다.
  3. 아직 지우지 않은 수들 중, P의 배수를 크기 순서대로 지운다.
  4. 아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.
- O(N log(log N))의 시간 복잡도
- bool 자료형 배열인 is_prime 안의 모든 요소들에 대하여, 처음에 True로 초기화
- 1은 소수가 아니므로, i값은 2부터 시작
- j는 i만큼 커지도록 하여, i를 제외한 n 이하의 모든 i의 배수를 빠르게 체크
  이후, is_prime[i] = True인 모든 i의 값은 소수가 됨

회문(Palindrome)
- 앞뒤 방향으로 볼 때, 같은 순서의 문자로 구성된 문자열을 의미
- 회문 예시 : "소주 만 병만 주소", "Madam, I'm Adam", "1234321"
- 회문을 판단하려면?

올바른 괄호 문자열(Valid Parenthesis String, VPS)
1. 빈 문자열은 올바른 괄호 문자열이다.
2. S가 올바른 괄호 문자열이라도, (S)도 올바른 괄호 문자열이다.
3. S,T가 올바른 괄호 문자열이라면, ST도 올바른 괄호 문자열이다.
S 가 입력될 때, S가 올바른 괄호 문자열인지 판단하여라.
보통은 스택(Stack)을 사용해서 해결하는 문제
")"가 입력될 때마다, 스택에 있는 ")"를 하나씩 지움
이때, 스택(top)이 비어있거나, "("가 없으면 올바른 괄호 문자열이 아님
모든 문자열을 순회한 뒤, 스택이 비어있으면 올바른 괄호 문자열이고, 비어있지 않으면 올바르지 않은 괄호 문자열임

- 정수형 변수 i를 0부터 s의 길이까지 반복
  만약 s[i]가 "("이라면 스택 st에 "("를 push
  그렇지 않으면, 만약 s[i]가 ")"이라면:
  만약 스택 st가 비어있다면: "NO"를 출력하고 프로그램 종료
  그렇지 않으면: 스택 st에서 요소를 pop
  만약 스택 st가 비어있다면 : "YES"를 출력
  그렇지 않으면 : "NO"를 출력

- 올바른 괄호 문자열 - 치환
  "("를 1, ")"를 -1로 치환
  문자열 S를 전부 순회하며 합 계산
  중간에 합이 음수가 되거나, 계산이 모두 끝나고 합이 0이 되지 않으면 올바른 괄호 문자열이 아님
  마지막에 합이 0이 아닌 것은 스택이 비어있지 않는 것과 같은 의미