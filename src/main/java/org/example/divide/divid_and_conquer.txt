Divide : 큰 문제를 작은 문제로 분할
 - 기저 사례(base case)를 잘 설정하여 일정 기준 이상 분할되지 않도록 해야 함
Cibqyer : 작은 문제의 답을 모아, 큰 문제의 답을 구함

- 이전에 배운 합병 정렬이 분할 정복의 대표적인 예
- 분할 정복은 재귀로 구현하는 것이 일반적

예시) 피보나치 수열
- N이 2이하일 때, 1 반환 -> 기저 사례(base case)
  F(1)값을 3번, F(2) 값을 5번 계산하여, F(6)을 구함
  -> 큰 문제를 작은 문제로 분할 + 작은 문제들의 답을 큰 문제의 답을 구함

백트래킹(backtracking)
- 답이 될  수 없는 경우는 탐색 대상에서 제외하여 효율적으로 답을 구하는 알고리즘
  가지치기(pruning)를 통해 연산량을 유의미하게 줄여줌
- 가지치기를 사용하기 위해서는 현재 상태에서 도달할 수 있는 상태가 모두 답이 될 수 없음을 보여야 함
- 정확한 시간 복잡도를 구하기 어려움

예시) 스도쿠(Sudoku)
- 가로, 세로, 3 * 3 칸 모두에,1에서 9까지의 숫자를 중복되지 않게 한 번씩 사용해야 함
- 스도쿠를 하다 보면, 명확한 근거 없이 일단 대입해 봐야 하는 분기점이 존재
- 대입해 보고 현재 상태에서 스도쿠를 완성할 수 없다면, 분기점으로 다시 돌아옴 -> 백트래킹

예시) Nqueen
- N * N 크기의 체스판에 N개의 퀸을 서로 공격하지 못하게 놓아보자.
- 단, 퀸은 같은 행, 열 대각선 위에 있는 말을 공격할 수 있다.

분할 정복과의 차이
- 공통점 : 주로 재귀적인 방식으로 해결
- 차이점 : 분할 정복은 하위 문제를 해결하고, 결과를 결합하여 문제 해결
        : 백트래킹은 문제 해결을 위해 모든 가능한 선택을 시도한 후, 가능성이 없다고 판단되면 이전 단계로 되돌아가거나 이전 결정을 변경

동적 계획법
- 이전에 계산한 값을 재사용하여, 하나의 문제를 한 번만 풀게 하는 알고리즘 패러다임
- DP는 Divide & Conquer와 비슷하지만, 중간 결과를 저장하여 효율성을 높인다는 점에서 차이
- 이전에 계산해둔 값을 메모리(배열 등)에 저장해서 반복 작업을 줄이는 기법이 핵심
- 하위 문제의 결과를 먼저 저장하고, 이를 나중에 필요할 때 사용
- Tabulation(bottom-up), Memoization(top-down)

Top-Down Dp
- 가장 큰 문제부터 풀기 시작하여, 작은 문제들을 재귀적으로 호출하여 답을 구하는 방식
- 주로 재귀를 통해 해결하고, 이때 메모이제이션(Memoization)을 활용하여 복잡도를 줄임

Bottom-Up DP
- 작은 문제들을 먼저 풀기 시작하여, 최종적으로 가장 큰 문제들을 해결하는 방식
- 주로 반복문을 통해 해결하고, 점화식과 기저 사례(base case)가 필요 -> tabulation

동적 계획법을 사용하는 조건
- 두 가지 속성을 만족해야 동적 계획법으로 문제를 해결할 수 있음
- 겹치는 부분(작은) 문제(Overlapping Subproblem)
- 어떠한 문제가 여러 개의 부분(하위) 문제(subproblem)으로 쪼갤 수 있을 때 사용
- 최적 부분 구조(Optimal Substructure)
  문제의 정답을 작은 문제의 정답에서 구할 수 있을 때 사용

피보나치 수열 - 재귀
- 파보나치 수열을 재귀로 구현할 시 발생하는 문제점
- 재귀함수를 통해 호출하게 되면, 이미 구했던 값도 다시 계산해야 함 -> 시간 초과 발생 및 stack overflow 가능성 높아짐

피보나치 수열 반복문
- 피보나치 수열을 재귀 함수로 구현 -> 시간 복잡도 : 0(2N)
  단순 반목문으로 구현 -> 시간 복잡도 : 0(N)

누적합
- Cumulative Sum으로도 불림
- 미리 구해놓은 배열을 통해 0(1)의 시간 복잡도로 쿼리(Query)를 해결

누적합의 장단점
- 빠른 구간 합 계산이 가능
- 상대적으로 간단한 구현
- 데이터 변경의 어려움
- 데이터가 변경되면, 변경될 때마다 구간합을 다시 계산해야 함
- 메모리 사용
- 구간합을 계산하여 저장해야 하므로, 추가적인 메모리가 필요