자료 구조
- 데이터를 저장하고 관리하는 방식(데이터의 흐름과 저장)

알고리즘
- 문제를 해결하는 방법(시간과 공간 효율성)

자료구조가 달라지면 알고리즘도 달라짐

자료 구조의 종류
- List
- Stack
- Queue
- Hash
- Tree
- Graph
- 때와 장소에 맞는 자료구조를 사용해야 함에 주의

배열이란? int[] arr = new int[size];
- 연속된 메모리 공간에 순차적으로 데이터를 저장하는 선형 자료구조
  indexing 및 slicing이 가능
- Python 등을 제외하면 대부분의 프로그래밍 언어에서 동일 타입의 데이터를 저장
- 인덱스는 0부터 시작
- 마지막 인덱스는 배열 요소의 개수 -1
- 각 요소는 인덱스를 통해 접근 가능

배열의 장점
- 인덱스를 이용한 접근이 가능하기 때문에 검색이 빠름
- 연속적이므로 메모리 공간을 효율적으로 사용 가능
  요소들이 순차적으로 저장되므로 캐시 지역성이 좋음
- 간단하고 사용 및 구현이 쉬움
- 참조를 위한 추가적인 메모리가 필요하지 않음

배열의 단점
- 배열을 선언한 후에는 할당된 정적 메모리 때문에 크기를 변경할 수 없음
- 삽입, 삭제에 비용이 많이 듦
  항상 메모리가 순차적으로 이어져 있어야 하기 때문
  다른 모든 요소를 이동해줘야 함
- 오버플로우나 저장 공간의 낭비를 초래할 수 있음
  삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것이 어려움

배열을 사용하는 경우
- 순차적인 데이터를 저장하며, 순서가 중요한 경우
- 특정 요소를 빠르게 읽어야 할 때
- 데이터의 사이즈가 자주 바뀌지 않으며, 요소의 추가 및 삭제가 적게 발생할 때
- 다차원의 데이터를 다룰 때

배열 연산
- 원하는 인덱스에 접근하는 시간복잡도는 0(1)
- 데이터 삽입에 걸리는 시간복잡도는 0(n)
  삽입을 위해 기존 데이터를 이동시켜줘야 하기 때문
- 데이터 삭제에 걸리는 시간복잡도는 0(n)
  마찬가지로 삭제 후, 기존 데이터를 이동시켜줘야 하기 때문

배열 반복문
- 배열의 모든 요소에 순차적으로 접근하기 위해 반복문을 사용

배열의 단점
- 길이 100의 배열을 선언했지만, 실제 사용 데이터는 10개 미만 -> 메모리 낭비
- 길이 100의 배열을 선언했지만, 실제 사용 데이터는 100개 초과 -> 메모리 부족
- 데이터 수에 맞춰 효율적으로 메모리를 활용할 수 있는 자료 구조는 없을까?

연결 리스트(Linked List)란?
- 데이터 목록을 다루는 가장 단순한 자료구조로, 데이터가 순차적으로 연결된 선형 구조를 띰
- 연결 리스트는 노드(Node)로 구성됨, 노드는 데이터를 저장하는 부분과 다음 노드에 대한 포인터로 구성
- 첫 번째 노드를 헤드(Head), 마지막 노드를 테일(Tail)이라 부름

연결 리스트(Linked List)의 장점
- 구조가 단순해서 구현이 편하고, 데이터의 추가, 삽입, 삭제가 쉬움
- 다음 노드의 포인터 정보를 통해 추가적인 연산 없이 다음 노드로 접근 가능
- 배열과 달리 메모리 공간을 효율적으로 사용 가능

연결 리스트(Linked List)의 단점
- 노드에 다음 노드의 포이터에 대한 정보가 필요하므로 메모리가 추가로 필요
- 인덱스를 통해 접근 가능한 배열과 달리 순차적인 접근만 지원하므로, 특정 요소 탐색 및 업데이트가 오래 걸림

연결 리시트의 종류
- 접근(Access) 시간 복잡도 : 0(N)
  인덱스 N에 접근하기 위해, 헤드 노드에서 다음 노드로 N번 이동
  배열의 경우에는 특정 인덱스에 바로 접근 가능 -> 0(1)
- 삽입/삭제 시간 복잡도 : 0(1)
  삽입, 삭제할 노드의 주변 노드만 수정하면 됨 -> 소요 시간이 특정 값에 비례하지 않고 항상 일정
- 배열의 경우에는 인덱스에 데이터를 삽입, 삭제하기 위해 기존 데이터를 옮기는 작업이 필요 -> 0(N)

이중 연결 리스트(Doubly Linked List)
- 특정 노드를 탐색해야 할 때 단방향으로 이동해야 하는 단방향 연결 리스트의 단점 해결 가능
- 삽입 및 삭제 연산이 빠름
- 단, 포인터를 위한 메모리 공간이 2배로 사용되며, 구현이 상대적으로 복잡

원형 연결 리스트(Doubly Linked List)
- 순환 구조로 인한 유연성으로 인해 리스트의 끝에서 시작으로 쉽게 이동할 수 있음
- 구현이 복잡하고 메모리 공간이 추가로 필요

스텍(Stack)이란?
- 쌓아놓은 더미
- 후입선출(LIFO : Last In First Out)
- First In Last Out
- 가장 최근에 들어온 데이터가 가장 먼저 나감
- 이로 인해 출력 순서가 입력 순서의 역순일 때 자주 사용하는 자료구조

스택의 연산들
- Push : 데이터를 스택의 가장 위에 추가
- Pop : 스택의 가장 위에 있는 요소(element)를 제거
- Top : 스택의 가장 위에 있는 요소를 반환
- Empty : 스택이 비어 있는지 확인
- Size : 스택에 있는 요소의 개수를 반환

큐(Queue)란?
- 한 줄로 기다리는 대기 줄
- 선입선출(FIFO : First In First Out)
- Last In Last Out
- 가장 최근에 들어온 데이터가 가장 나중에 나감
- 입력된 순서대로 처리해야 할 상황에서 자주 사용하는 자료구조

큐의 연산들
- Enqueue : 큐의 맨 뒤에 요소 추가
- Dequeue : 큐의 맨 앞 요소를 제거
- Front : 큐의 맨 앞 요소를 반환
- Empty : 큐가 비어 있는지 확인
- Size : 큐에 있는 요소의 개수를 반환