완전 탐색
- 모든 경우를 탐색하는 기법
- 브투트 포스(Brute-Force)로도 불림

예시
- 크기가 N인 배열이 있고, 배열 안의 요소들은 모두 양의 정수이며, 오름차순으로 정렬되어 있다.
  이때, 배열 안에서 중복되지 않게 두 개를 골라 곱하였을 때의 최대값을 구하여라.
- 두 수를 선택하는 경우의 수는
  시간 복잡도 : 0(N2)
  모든 경우의 수 탐색 -> 완전 탐색
- 배열의 가장 뒤에 있는 요소와 2번째로 뒤에 있는 요소를 곱함
  시간 복잡도 : 0(1)
  모든 경우의 수를 탐색하지 않음 -> 그리디

그리디(Greedy)
- 선택의 순간마다, 당장 눈앞에 보이는 최적의 상황만을 쫒아 최종적인 해답에 도달하는 방법
- 탐욕스러운(Greedy)기법
- 순간마다 하는 선택은 그 순간에 대해 지역적으로는 최적
- 그 선택들이 모이면 최종적(전역적)으로도 최적이 보장될까?

그리디를 적용할 수 있는 조건 2가지
- 탐욕적 선택 속성(greedy choice property)
- 앞 선택이 뒤의 선택에 영향을 주지 않고, 항상 현재 상황에 유리한 선택을 함
- 최적 부분 구조(optimal substructure)
- 전체 문제를 해결하는 최적의 해결 방법이, 각 부분 문제를 해결하는 최적의 해결 방법의 조합으로 이루어져야 함

예시
- 1000원짜리 커피를 500원짜리 동전과 100원짜리 동전만 사용하여 계산하려고 한다.
  동전을 가장 적게 사용하여 계산하려고 할 때, 필요한 동전의 최소 개수는? (단, 동전은 무수히 많다.)
- 100원짜리 5개 사용하는 것보다 500원 짜리 동전 하나를 사용하는 것이 항상 최적 -> 그리디 알고리즘으로 해결 가능

재귀(Recursion)
- 재귀 : 자신을 정의할 때, 자기 자신을 참조하는 것
- 재귀 함수 : 함수 내부에서 자기 자신을 호출하는 함수

재귀의 필요성
- 변수의 사용을 줄여, 프로그램을 더 간결하고 이해하기 쉽게 만들 수 있음
- 재귀 함수는 복잡한 문제를 간단한 기본 단계(base case)로 나누고, 이러한 기본 단계에서 해결하는 방식을 통해 문제를 해결할 수 있게 함

재귀 함수 작성 시 주의할 점
- 무한 루프에 빠지지 않도록 종료 조건을 잘 설정
- 종료 조건을 기저 사례(base case)라고도 함
- 함수의 파라미터 및 인자 설정에 유의
- 알고리즘 입문자들이 어려워하기 쉬운 부분이 재귀
- 재귀는 이후에 배울 알고리즘의 밑바탕이 되니 꼭 숙지

정렬(Sorting)
- 정렬이 필요한 이유?
  오름차순 및 내림차순으로 정렬되어 있다면 특정 원소를 좀 더 효율적으로 찾을 수 있음
- 특정 정렬이 빠르다고 항상 좋은 것은 아님
- 데이터의 특성, 크기에 따라 적절한 정렬 방법을 사용해야 함

삽입 정렬(Insertion Sort)
- 배열의 모든 원소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성
- 배열이 길어질수록 효율이 떨어지지만, 구현이 간단하다는 장점 존재

버블 정렬(Bubble Sort)
- 배열의 인접한 두 수를 선택하여, 정렬되지 않았다면 두 수를 바꿈(swap)
- 이를 배열의 처음부터 끝까지 반복하고, 배열에 아무 변화가 없을 때까지 함
- 구현이 간단하지만, 느림

합병 정렬(Merge Sort)
- 정렬되지 않은 리스트를 각각 하나의 원소만 포함하는 n개의 부분 리스트로 분할
  (원소의 개수가 하나인 리스트는 이미 정렬된 것으로 봄)
- 부분 리스트가 하나만 남을 때까지 반복해서 병합하며 정렬된 부분 리스트를 생성
- 마지막 남은 부분 리스트가 정렬된 리스트

퀵 정렬(Quick Sort)
- 배열의 요소들 중에서 피벗(Pivot)을 정하여, 피벗의 앞에는 피벗보다 작은 원소들이 오고, 피벗 뒤에는 피벗보다 큰 값이 오도록 배열을 둘로 나눔
- 분할된 두 개의 배열의 크기가 0이나 1이 될 때까지, 분할된 두 배열에 대해 재귀적으로 이 과정을 반복
- 재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소가 최종적인 위치에 있게 되므로, 종료됨이 보장

힙 정렬(Heap Sort)
- 최대 힙 구성
  최대 힙이란 부모 노드가 자식 노드보다 큰 트리를 의미
- 현재 합에서 가장 큰 값(루트의 값)을 마지막 요소와 바꾼 후, 합의 사이즈를 하나 줄이고 최대 힙 구성
- 힙의 사이즈가 1이 될 때까지 위 과정을 반복

정렬(Sorting)
- 언어들의 라이브러리 내장 sort 함수 구현
- C++은 sort 함수 내부에 일반적으로 인트로 정렬로 구현되어 있음
  인트로 정렬(Intro Sort) : 퀵 정렬 + 힙 정렬 + 삽입 정렬
- Python은 팀 정렬(Tim Sort)
  팀 정렬 : 합병 정렬 + 삽입 정렬
- Java는 Java7 이전에는 병합 정렬, 이후에는 팀 정렬

투 포인터(Two Pointer)
- 이름 그대로 포인터 2개를 사용해 두 점의 위치를 기록해가며 문제를 해결하는 기법(technique)
- 1차원 배열을 순차적으로 접근해야 할 때 사용
- 두 포인터의 이름은 다양하게 불림
  (s,e),(st,en),(start,end),(l,r),(left,right)
- 시간 복잡도는 일반적으로 0(N)

슬라이딩 윈도우(Sliding Window)
- 슬라이딩 윈도우 -> 창문을 밀대로 닦는다
- 고정 사이즈의 윈도우(Window)가 이동하면서, 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 기법(technique)
- 투 포인터와 비슷하지만, 범위가 고정되어 있을 때 사용한다는 점에서 차이가 있음(두 포인터가 같이 이동)
- 시간 복잡도는 일반적으로 0(N)

