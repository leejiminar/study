테스트의 필요성
- 소프트웨어 개발의 핵심 과정 중 하나로, 코드의 안정성, 기능성, 성능 검증에 필수적
- 소프트웨어 개발 과정에서 버그나 오류를 미리 찾아 사용자에게 안정적인 서비스 제공
- 테스트를 통해 모든 버그를 사전에 방지할 수는 없으나 테스팅을 생략할 시, 예상치 못한 버그나 오류 발생률이 높아짐

테스팅의 장점
- 버그 발견 : 초기 단계에서 오류 발견으로 개발 비용 절감
- 성능 최적화 : 테스팅을 통해 성능 저하 요인을 찾아내 개선
- 기능 검증 : 사용자 요구사항에 맞게 기능이 정상적으로 동작하는지 확인
- 고객 만족도 향상 : 안정적인 제품으로 고객 신뢰 향상
- 재배포 및 재개발 비용 감소 : 안정적 제품 출시로 오류로 인한 재배포나 재개발 필요성 감소
- 효율적 리소스 활용 : 테스팅을 통해 성능 문제를 사전에 파악, 최적화 가능
- 장기적 비용 절감 : 서버 리소스의 효율적 활용으로 인한 비용 감소
- 유지보수의 용이성 : 코드의 품질을 높여 변경이나 확장 시 유지 보수 용이

좋은 테스팅을 위한 FIRST 원칙
- 테스트 코드 작성에 있어서 중요한 5가지 원칙
- Fast : 테스트는 지속적이고 빠른 피드백을 줄 수 있게 유지되어야 함
- Independent : 테스트는 서로 독립적이어야 함
              - 좋은 단위 테스트는 작은 양의 코드에 집중해 검증함
                다른 단위 테스트에 읜존하거나 외부 코드와의 의존성을 가질 경우, 테스트가 실패했을 때 추적이 까다로워 짐
              - 테스트 코드를 집중적으로 유지하기 쉬워지게 해야함
- Repeatable : 어떤 환경에서도 테스트는 반복 가능해야 함
             - 실행할 때마다 결과가 항상 같아야 함 / 진짜 버그가 아닌 테스트의 문제일 수 있음
- Self-validation : 테스트는 스스로 검증 가능해야 함 / 자동화된 테스트
                  - ex) CI/CD 환경에서 repository에 코드를 반영할 때마다 자동으로 빌드가 수행되고 모든 테스트를 실행하게 하는 것
- Timely : 적절한 시기에 테스트를 작성해야 함
         - 조직에 따라 테스트 작성 시점, 코드 리뷰 프로세스 등의 정책을 사용하기도 함
         - 개인의 경우 실천습관과 작은 단위의 테스트 코드 작성을 훈련

Junit 이란?
- JUnit은 Java 언어를 위한 대표적인 단위 테스팅 프레임워크
- 최신버전 : JUnit5
- Spring Boot 2.2 이상 버전을 사용한다면, JUnit5 의존성이 추가되어 있음

Junit 이해하기
- Test 메소드는 @Test 어노테이션이 붙어있으며, public void 이며 파라미터를 받지 말아야 함
- test가 Assertion 예외 (기본값일 경우)를 발생시키지 않으면 성공

Junit 생명주기
- JUnit 테스트의 시작부터 종료까지의 과정으로 각 단계에서는 특정 작업이 수행되며, 이를 통해 테스트가 원활하게 진행됨
- 테스트 클래스 인스턴스 새로 생성
- 생성한 클래스 인스턴스가 가지고 있는 테스트 환경준비(setup) 메서드를 찾아 모두 호출
- 테스트 메서드 호출
- 테스트 클래스 인스턴스가 가지고 있는 테스트 환경정리(teardown) 메서드를 찾아 모두 호출

Junit 격리보장 Junit 생명주기
- 테스트 환경준비(setup) 메소드는 각 테스트가 실행되기 전에 호출됨
- 이 메소드를 통해 테스트에 필요한 초기 설정을 할 수 있음
  ex) 테스트 데이터를 준비하거나 객체를 초기화하는 작업 가능
- 테스트 환경정리(teardown) 메소드는 각 테스트가 종료된 후에 호출됨
- 테스트에서 사용한 리소스를 해제하거나, 테스트 데이터를 정리하는 작업을 함 이로써 다음 테스트가 깨끗한 상태에서 시작될 수 있게 도와줌

어노테이션을 통한 생명 주기 관리
- @BeforeEach : 각 테스트 메서드 실행 전에 수행되는 작업을 정리
- @AfterEach : 각 테스트 메서드 실행 후에 수행되는 작업을 정리
- @Test : 실제 테스트 케이스를 정리
- @BeforeAll, @AfterAll : 테스트 클래스의 시작과 종료 시점에 한 번 씩만 수행되는 작업을 정의

Assert API
- 테스트 중에 특정 조건이 참인지 확인하는 함수로, 테스트 케이스의 실행 결과가 예상대로 인지 확인함
- Assert 메서드의 조건이 만족되지 않으면 테스트는 실패로 간주
- assertEquals(expected, actual) : 기대값(expected)과 실제값(actual)이 동일한지 확인
                                   ex) assertEquals(5, 2+3);
- assertNotEquals(unexpected, actual) : 기대하지않은 값과 실제값(actual)이 틀린게 맞는지 확인
- assertTrue(condition) : 주어진 조건(condition) 이 true인지 확인
                          ex) assertTrue(a>b);
- assertFalse(condition) : 주어진 조건(condition)이 false인지 확인
- assertNull(object) : 주어진 객체가 null인지 확인
- assertNotNull(Object) : 주어진 object가 null이 아닌지 확인
- assertSame(expected, actual) : expected와 actual이 동일한 객체를 참조하는지  확인
- assertNotSame(unexpected, actual) : unexpected와 actual이 다른 객체를 참조하는지 확인
- assertArrayEquals(expectedArray, actualArray) : 두 배열이 동일한 순서와 값을 가지는지 확인
- assertThrows(expectedException, executable) : 주어진 executable이 expectedException을 발생시키는지 확인
- assertThat(T actual, Matcher<? Super T> matcher)
- actual: 검증하려는 실제 값
- matcher: 실제 값에 적용되는 조건을 정의하는 객체
- 주어진 실제 값과 매처(matcher)를 사용하여 예상되는 조건을 비교
- Hamcrest 라이브러리와 함께 사용 가독성 높은 테스트 코드 작성 지원
- 테스트코드를 읽기 쉬워서 테스트의 의도를 명확하게 파악 가능

Given When Then 패턴
- Given : 테스트의 전제 조건을 설정하는 단계 ex)테스트에 필요한 객체 생성 또는 초기화 작업
- When : 실제로 테스트하려는 로직을 실행하는 단계
- Then : 실행 결과를 검증하는 단계, 예상 결과와 실제 결과를 비교해 테스트 성공 여부 판단

@DisplayName 사용의 이점
- 테스트 목적을 명확히 표현
- 복잡한 비즈니스 규칙 설명 가능
- 테스트 결과 보고서의 가독성 향상
- 비개발자와의 커뮤니케이션 개선
- 테스트 문서화 효과

Mock 객체 활용 테스트
- Mock 객체는 테스트 환경에서 실제 객체의 행동을 모방하는 객체
- 테스트의 단순화, 격리, 상황, 모방, 행동 검증, 성능 향상을 위해 사용

- 의존성 분리
  1. 코드는 다른 코드나 외부 시스템에 의존성을 가짐
  2. 테스트 시, 외부 의존성 때문에 복잡성 증가
  3. Mock 객체로 외부 의존성을 모방하여 테스트 환경에서만 동작

- 테스트의 단순화 및 격리
  1. Mock 객체로 테스트 대상 코드만 집중적으로 테스트
  2. 데이터베이스 연결 실패 등의 경우에도 영향을 받지 않게 함

- 특정 상황 및 예외 상황 모방
  1. 특정 상황이나 예외 상황을 쉽게 모방
  2. 외부 AP 호출 실패, 데이터를 찾을 수 없는 경우 등을 재현

- 행동 검증
  1. 테스트 대상 코드의 예상대로 동작을 검증
  2. 서비스 메서드의 호출 횟수, 호출 인자 등을 검증
- 테스트 성능 향상
  1. 실제 객체나 외부 시스템 접근은 시간 소요
  2. Mock 객체 사용으로 테스트 실행 시간 단축

Mockito
- Mockito는 Java를 위한 Mocking 프레임워크
- Mockito를 사용하면 단위 테스트를 위해 실제 객체를 모방 Mock 객체를 쉽게 생성 관리 가능
- 이를 통해 테스트의 격리를 유지하면서, 테스트 대상 코드와 의존성 사이의 상호작용을 검증 또는 특정 상황을 시뮬레이션 할 수 있음

Spring Boot 애플리케이션의 테스팅 구조
- 테스트 계층의 이해 : 단위테스트, 스라이스 테스트, 통합테스트
- 단위 테스트(Unit Test)
  목적 : 개별 컴포넌트나 함수의 동작을 검증, 외부의 의존성 없이 코드의 특정 부분만을 대상으로 함
  특징 : 가장 빠르게 실행됨, Mock 객체나 스텁을 사용하여 외부 의존성을 제거함, JUnit, Mockito 등의 라이브러리를 주로 사용함
  예시 : 서비스 레이어드의 메서드, 유틸리티 함수 등의 동작을 검증함

- 슬라이스 테스트(Slice Test)
  목적 : 애플리케이션의 특정 계층 또는 부분만을 대상으로 테스트함, 데이터베이스, 웹 계층, 서비스 계층 등의 특정 슬라이스를 대상으로 함
  특징 : @WebMvcTest, @DataJpaTest 등의 슬라이스 테스트 어노테이션을 사용
  예시 : @WebMvcTest를 사용하여 컨트롤러 계층만을 대상으로 한 테스트
        @DataJpaTest를 사용하여 JPA 엔티티와 리포지토리 계층의 테스트

- 통합 테스트(Integration Test)
  목적 : 여러 컴포넌트나 시스템 간의 상호 작용을 검증함, 전체 애플리케이션의 동작을 테스트함
  특징 : @SpringBootTest 어노테이션을 사용하여 전체 애플리케이션 컨테스트를 로드, 실제 데이터베이스, 외부 서비스 등과의 통신을 포함할 수 있음
  예시 : REST API의 엔드포인트 호출과 응답을 검증하는 테스트, 여러 서비스 레이어의 상호 작용과 결과를 검증하는 테스트
  1. 테스트 데이터베이스 설정 - H2, Testcontainers 활용
  2. 전체 애플리케이션의 통합 테스팅 - 서비스, 리포지토리, 컨트롤러를 포함한 전체 테스트


